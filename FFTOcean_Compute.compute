#pragma kernel CS_InitializeSpectrum
#pragma kernel CS_PackSpectrumConjugate
#pragma kernel CS_UpdateSpectrum
#pragma kernel CS_HorizontalIFFT
#pragma kernel CS_VerticalIFFT
#pragma kernel CS_AssembleTextures

float _Depth, _Gravity, _FrameTime, _RepeatTime, _LowCutOff, _HighCutOff;
float2 _WaveSharp;
int _Resolution, _LengthScale0, _LengthScale1, _LengthScale2, _LengthScale3, _Seed;
float _FoamBias, _FoamDecayRate, _FoamAdd, _FoamPower;

#define PI 3.14159265358979323846

RWTexture2DArray<float4> _InitialSpectrumTexture;
RWTexture2DArray<float4> _SpectrumTexture;
RWTexture2DArray<float4> _DisplacementTexture;
RWTexture2DArray<float2> _SlopeTexture;
RWTexture2D<half> _BuoyancyData;
RWTexture2D<float4> _VariationMask;

struct JONSWAP_parameters{
    float scale;
	float angle;
	float spreadBlend;
	float swell;
	float alpha;
	float peakOmega;
	float gamma;
	float shortWavesFade;
};

StructuredBuffer<JONSWAP_parameters> _JonswapParameters;
float2 EnlerFormula(float x)
{
    return float2(cos(x), sin(x));
}

float2 ComplexMul(float2 a, float2 b)
{
    return float2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

float hash(uint n){
    n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 0x789221U) + 0x1376312589U;
    return float(n & uint(0x7fffffffU)) / float(0x7fffffff);
}

float2 gaussian(float u1, float u2){
    float R = sqrt(-2 * log(u1));
    float theta = 2 * PI * u2;

    return float2(R * cos(theta), R * sin(theta));
}

float Dispersion (float k){
    return sqrt(_Gravity * k * tanh(min(k * _Depth, 20)));
}

float DispersionDerivative(float kMag) {
    float tanh = tanh(min(kMag * _Depth, 20));
    float cosh = cosh(kMag * _Depth);
    return _Gravity * (_Depth * kMag / cosh / cosh + tanh) / Dispersion(kMag) / 2.0f;
}

float NormalizationFactor(float s)
{
    float s2 = s * s;
    float s3 = s2 * s;
    float s4 = s3 * s;

    if(s < 5)
        return -0.000564f * s4 + 0.00776f * s3 - 0.044f * s2 + 0.192f * s + 0.163f;
    else
        return -4.80e-08f * s4 + 1.07e-05f * s3 - 9.53e-04f * s2 + 5.90e-02f * s + 3.93e-01f;
}

float Cosine2s (float theta, float s)
{
    return NormalizationFactor(s) * pow(abs(cos(0.5f * theta)), 2.0f * s);
}

float SpreadPower(float omega, float peakOmega)
{
    float ratio = abs(omega / peakOmega);
    if(omega <= peakOmega)
        return 6.97f * pow(ratio, 5.0f);
    else
        return 9.77f * pow(ratio, -2.5f);
}

float DirectionSpectrum(float theta, float omega, JONSWAP_parameters parameters)
{
    float s = SpreadPower(omega, parameters.peakOmega)
            + 16 * tanh(min(omega / parameters.peakOmega, 20)) * parameters.swell * parameters.swell;
    
    return lerp(2.0f * PI * cos(theta) * cos(theta), Cosine2s(theta - parameters.angle, s), parameters.spreadBlend);
}

float TMACorrection(float omega){
    float omegaH = omega * sqrt(_Depth / _Gravity);
    if (omegaH <= 1.0f)
		return 0.5f * omegaH * omegaH;
	if (omegaH < 2.0f)
		return 1.0f - 0.5f * (2.0f - omegaH) * (2.0f - omegaH);

	return 1.0f;
}

float JONSWAP(float omega, JONSWAP_parameters parameters){
    float sigma = (omega <= parameters.peakOmega) ? 0.07f : 0.09f;

    float r = exp(-(omega - parameters.peakOmega) * (omega - parameters.peakOmega) / 2.0f / sigma / sigma / parameters.peakOmega / parameters.peakOmega);

    float oneOverOmega = 1.0f / omega;
    float peakOmegaOverOmega = parameters.peakOmega / omega;

    float Sw = parameters.scale * TMACorrection(omega)
            * parameters.alpha * _Gravity * _Gravity
            * oneOverOmega * oneOverOmega * oneOverOmega * oneOverOmega * oneOverOmega
            * exp(-1.25f * peakOmegaOverOmega * peakOmegaOverOmega * peakOmegaOverOmega * peakOmegaOverOmega)
            * pow(abs(parameters.gamma), r);
            
    return Sw;
}

float ShortWaveFade(float kLength, JONSWAP_parameters parameters){
    return exp(-parameters.shortWavesFade * parameters.shortWavesFade * kLength * kLength / 10000);
}

[numthreads(8,8,1)]
void CS_InitializeSpectrum(uint3 id : SV_DISPATCHTHREADID)
{
    float seed = id.x + id.y * _Resolution + _Resolution;
    seed += _Seed;

    float LengthScale[] = {_LengthScale0, _LengthScale1, _LengthScale2, _LengthScale3};
    for(uint i = 0; i < 4; i++)
    {
        float halfN = _Resolution / 2.0f;
        float deltaK = 2.0f * PI / LengthScale[i];
        float2 k = (id.xy - halfN) * deltaK;
        float kLength = length(k);

        seed += i + hash(seed) * 10;
        float2 gauss1 = gaussian(hash(seed), hash(seed * 2));
        float2 gauss2 = gaussian(hash(seed * 3), hash(seed * 4));

        if(_LowCutOff <= kLength && kLength <= _HighCutOff)
        {
            float omega = Dispersion(kLength);
            float kAngle = atan2(k.y, k.x);

            float dOmegadk = DispersionDerivative(kLength);

            float JONSpectrum = JONSWAP(omega, _JonswapParameters[i * 2]) * DirectionSpectrum(kAngle, omega, _JonswapParameters[i * 2]) * ShortWaveFade(kLength, _JonswapParameters[i * 2]);
            
            if(_JonswapParameters[2 * i + 1].scale > 0)
                JONSpectrum += JONSWAP(omega, _JonswapParameters[i * 2 + 1]) * DirectionSpectrum(kAngle, omega, _JonswapParameters[i * 2 + 1]) * ShortWaveFade(kLength, _JonswapParameters[i * 2 + 1]);

            float2 H0 = float2(gauss1.x, gauss2.y)* sqrt(JONSpectrum * 2 * abs(dOmegadk) / kLength * deltaK * deltaK);
            
            _InitialSpectrumTexture[uint3(id.xy, i)] = float4(H0, 0, 0);
        } else {
            _InitialSpectrumTexture[uint3(id.xy, i)] = 0.0f;
        }
    }
    
}

[numthreads(8, 8, 1)]
void CS_PackSpectrumConjugate(uint3 id : SV_DISPATCHTHREADID)
{
    for(uint i = 0; i < 4; i++)
    {
        float2 h0 = _InitialSpectrumTexture[uint3(id.xy, i)].rg;
        float2 h0conju = _InitialSpectrumTexture[uint3((_Resolution - id.x) % _Resolution, (_Resolution - id.y) % _Resolution, i)].rg;

        _InitialSpectrumTexture[uint3(id.xy, i)] = float4(h0, h0conju.x, -h0conju.y);
    }
}

[numthreads(8, 8, 1)]
void CS_UpdateSpectrum(uint3 id :SV_DISPATCHTHREADID)
{
    float LengthScale[] = {_LengthScale0, _LengthScale1, _LengthScale2, _LengthScale3};

    for(int i = 0; i < 4; ++i)
    {
        float4 Initial = _InitialSpectrumTexture[uint3(id.xy, i)];
        float2 h0 = Initial.xy;
        float2 h0conju = Initial.zw;

        float halfRes = _Resolution / 2.0f;
        float2 k = (id.xy - halfRes) * 2.0f * PI / LengthScale[i];
        float kLength = length(k);
        float kLengthRcp = rcp(kLength);

        if(kLength < 0.0001f)
        {
            kLengthRcp = 1.0f;
        }

        float w0 = 2.0f * PI / _RepeatTime;
        float dispersion = floor(sqrt(_Gravity * kLength) / w0) * w0 * _FrameTime;

        float2 exponent = EnlerFormula(dispersion);

        float2 htime = ComplexMul(h0, exponent) + ComplexMul(h0conju, float2(exponent.x, -exponent.y));
        float2 ihtime = float2(-htime.y, htime.x);

        float2 displacementX = ihtime * k.x * kLengthRcp;
        float2 displacementY = htime;
        float2 displacementZ = ihtime * k.y * kLengthRcp;

        float2 displacementX_dx = -htime * k.x * k.x * kLengthRcp;
        float2 displacementY_dx = ihtime * k.x;
        float2 displacementZ_dx = -htime * k.x * k.y * kLengthRcp;

        float2 displacementY_dz = k.y * ihtime;
        float2 displacementZ_dz = -htime * k.y * k.y * kLengthRcp;

        float2 htimeDisplacementX = float2(displacementX.x - displacementZ.y, displacementX.y + displacementZ.x);
        float2 htimeDisplacementZ = float2(displacementY.x - displacementZ_dx.y, displacementY.y + displacementZ_dx.x);
            
        float2 htimeSlopeX = float2(displacementY_dx.x - displacementY_dz.y, displacementY_dx.y + displacementY_dz.x);
        float2 htimeSlopeZ = float2(displacementX_dx.x - displacementZ_dz.y, displacementX_dx.y + displacementZ_dz.x);
        
        _SpectrumTexture[uint3(id.xy, i * 2)] = float4(htimeDisplacementX, htimeDisplacementZ);
        _SpectrumTexture[uint3(id.xy, i * 2 + 1)] = float4(htimeSlopeX, htimeSlopeZ);

        if(i == 0){
            _VariationMask[uint2(id.xy)] = float4(_InitialSpectrumTexture[uint3(id.xy, 0)].x, 0.0f, 0.0f, 0.0f);
        }
    }
    
}


#define SIZE 1024
#define LOG_SIZE 10

RWTexture2DArray<float4> _FourierTarget;
RWTexture2D<float4> _FourierTargetExtra;

groupshared float4 fftGroupBuffer[2][SIZE];

void ButterFlyValues(uint step, uint index, out uint2 index2, out float2 twiddle)
{
    const float twoPi = 6.28318530718;
    uint b = SIZE >> (step + 1);
    uint w = b * (index / b);
    uint i = (w + index) % SIZE;
    sincos(-twoPi / SIZE * w, twiddle.y, twiddle.x);

    twiddle.y = -twiddle.y;
    index2 = uint2(i, i + b);
}

float4 IFFT(uint threadIndex, float4 input)
{
    fftGroupBuffer[0][threadIndex] = input;
    GroupMemoryBarrierWithGroupSync();
    bool flag = false;

    [unroll]
    for(uint step = 0; step < LOG_SIZE; ++step)
    {
        uint2 outputIndices;
        float2 twiddle;
        ButterFlyValues(step, threadIndex, outputIndices, twiddle);

        float4 v = fftGroupBuffer[flag][outputIndices.y];
        fftGroupBuffer[!flag][threadIndex] = fftGroupBuffer[flag][outputIndices.x] + float4(ComplexMul(twiddle, v.xy), ComplexMul(twiddle, v.zw));

        flag = !flag;
        GroupMemoryBarrierWithGroupSync();
    }

    return fftGroupBuffer[flag][threadIndex];
}

[numthreads(SIZE, 1, 1)]
void CS_HorizontalIFFT(uint3 id : SV_DISPATCHTHREADID)
{
    for(int i = 0; i < 8; ++i)
    {
        _FourierTarget[uint3(id.xy, i)] = IFFT(id.x, _FourierTarget[uint3(id.xy, i)]);
    }

    _FourierTargetExtra[uint2(id.xy)] = IFFT(id.x, _FourierTargetExtra[uint2(id.xy)]);
}

[numthreads(SIZE, 1, 1)]
void CS_VerticalIFFT(uint3 id : SV_DISPATCHTHREADID)
{

    for(int i = 0; i < 8; ++i)
    {
        _FourierTarget[uint3(id.yx, i)] = IFFT(id.x, _FourierTarget[uint3(id.yx, i)]);
    }

    _FourierTargetExtra[uint2(id.yx)] = IFFT(id.x, _FourierTargetExtra[uint2(id.yx)]);
}

float4 Permute(float4 data, float3 id)
{
    return data * (1.0f - 2.0f * ((id.x + id.y) % 2));
}

[numthreads(8, 8, 1)]
void CS_AssembleTextures(uint3 id : SV_DISPATCHTHREADID)
{
    for(int i = 0; i < 4; ++i)
    {
        float4 htimeDisplacement = Permute(_SpectrumTexture[uint3(id.xy, i * 2)], id);
        float4 htimeSlope = Permute(_SpectrumTexture[uint3(id.xy, i * 2 + 1)], id);
        float4 variation = Permute(_VariationMask[uint2(id.xy)], id);

        float2 DxDy = htimeDisplacement.rg;
        float2 DyDxz = htimeDisplacement.ba;
        float2 DyxDyz = htimeSlope.rg;
        float2 DxxDzz = htimeSlope.ba;

        float jacobian = (1.0f + _WaveSharp.x * DxxDzz.x) * (1.0f + _WaveSharp.y * DxxDzz.y) - _WaveSharp.x * _WaveSharp.y * DyDxz.y * DyDxz.y;
        jacobian = pow(saturate(jacobian), _FoamPower);

        float3 finalDisplace = float3(DxDy.x * _WaveSharp.x, DyDxz.x, DxDy.y * _WaveSharp.y);
        float2 finalSlope = DyxDyz.xy / (1 + abs(DxxDzz * _WaveSharp));

        float foam = _DisplacementTexture[uint3(id.xy, i)].a;
        foam *= exp(-_FoamDecayRate);
        foam = saturate(foam);

        float biasedJacobian = max(0.0f, -(jacobian - _FoamBias));

        if(biasedJacobian > 0)
            foam += _FoamAdd * biasedJacobian;

        _DisplacementTexture[uint3(id.xy, i)] = float4(finalDisplace, foam);
        _SlopeTexture[uint3(id.xy, i)] = float2(finalSlope);

        if(i == 0) {
            _BuoyancyData[id.xy] = finalDisplace.y;
            _VariationMask[uint2(id.xy)] = variation;
        }
    }
}
